#! /bin/bash


# usefull resources
# http://www.askapache.com/linux/bash-power-prompt.html
# http://www.maketecheasier.com/8-useful-and-interesting-bash-prompts/
# http://bashrcgenerator.com/
# https://wiki.archlinux.org/index.php/Color_Bash_Prompt
# http://ithaca.arpinum.org/2013/01/02/git-prompt.html

# Characters prefixed by a backslash (\) are actually variables that get expanded. Here is a list of all Bash prompt variables as described in the PROMPTING section of the BASH(1) man page.
# \a 	an ASCII bell character (07)
# \d 	the date in "Weekday Month Date" format (e.g., "Tue May 26")
# \D{format} 	the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required.
# \e 	an ASCII escape character (033)
# \h 	the hostname up to the first .
# \H 	the full hostname
# \j 	the number of jobs currently managed by the shell
# \l 	the basename of the shells terminal device name
# \n 	newline
# \r 	carriage return
# \s 	the name of the shell, the basename of $0 (the portion following the final slash)
# \t 	the current time in 24-hour HH:MM:SS format
# \T 	the current time in 12-hour HH:MM:SS format
# \@ 	the current time in 12-hour am/pm format
# \A 	the current time in 24-hour HH:MM format
# \u 	the username of the current user
# \v 	the version of bash (e.g., 2.00)
# \V 	the release of bash, version + patch level (e.g., 2.00.0)
# \w 	the current working directory, with $HOME abbreviated with a tilde
# \W 	the basename of the current working directory, with $HOME abbreviated with a tilde
# \! 	the history number of this command
# \# 	the command number of this command
# \$ 	if the effective UID is 0, a #, otherwise a $
# \nnn 	the character corresponding to the octal number nnn
# \\ 	a backslash
# \[ 	begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
# \] 	end a sequence of non-printing characters 

# source easy to type bash color
if [[ -f "$HOME/.bash_colors" ]]; then
  source $HOME/.bash_colors;
fi

# \u@\h   user@host
# \$    display # for root, $ for normal users

# HH:MM [ user@host ] ~/current/path
# currentdir $
# PS1="${debian_chroot:+($debian_chroot)} \A [ \u@\h ] \w\n\W\ $"
PS1="${debian_chroot:+($debian_chroot)} \[$IPurple\]\t \[$BIBlue\][ \u@\H ] \[$BIWhite\]\w\n\W \[$BIGreen\]$\[$White\]\[$On_Black\] "

# Examples
# PS1="\[$blue\]┌─[\[$white\]\@\[$blue\]]─[\[$white\]\u\[$blue\]]─[\[w$hite\]\w\[$blue\]]\n└─[\[$white\]\$\[$blue\]]─>\[$white\]  "

# only show current folder on path
# PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\W\[\033[00m\]\$'

# free memory
# echo -en "$(( $(sed -nu "s/MemFree:[\t ]\+\([0-9]\+\) kB/\1/p" /proc/meminfo)/1024))/$(($(sed -nu "s/MemTotal:[\t ]\+\([0-9]\+\) kB/\1/Ip" /proc/meminfo)/1024 ))MB"

# My awesome bash prompt
#
# Copyright (c) 2012 "Cowboy" Ben Alman
# Licensed under the MIT license.
# http://benalman.com/about/license/
#
# Example:
# [master:!?][cowboy@CowBook:~/.dotfiles]
# [11:14:45] $
#
# Read more (and see a screenshot) in the "Prompt" section of
# https://github.com/cowboy/dotfiles

# ANSI CODES - SEPARATE MULTIPLE VALUES WITH ;
#
#  0  reset          4  underline
#  1  bold           7  inverse
#
# FG  BG  COLOR     FG  BG  COLOR
# 30  40  black     34  44  blue
# 31  41  red       35  45  magenta
# 32  42  green     36  46  cyan
# 33  43  yellow    37  47  white

if [[ ! "${prompt_colors[@]}" ]]; then
  prompt_colors=(
    "36" # information color
    "37" # bracket color
    "31" # error color
  )

  if [[ "$SSH_TTY" ]]; then
    # connected via ssh
    prompt_colors[0]="32"
  elif [[ "$USER" == "root" ]]; then
    # logged in as root
    prompt_colors[0]="35"
  fi
fi

# Inside a prompt function, run this alias to setup local $c0-$c9 color vars.
alias prompt_getcolors='prompt_colors[9]=; local i; for i in ${!prompt_colors[@]}; do local c$i="\[\e[0;${prompt_colors[$i]}m\]"; done'

# Exit code of previous command.
function prompt_exitcode() {
  prompt_getcolors
  [[ $1 != 0 ]] && echo " $c2$1$c9"
}

# Git status.
function prompt_git() {
  prompt_getcolors
  local status output flags branch
  status="$(git status 2>/dev/null)"
  [[ $? != 0 ]] && return;
  output="$(echo "$status" | awk '/# Initial commit/ {print "(init)"}')"
  [[ "$output" ]] || output="$(echo "$status" | awk '/# On branch/ {print $4}')"
  [[ "$output" ]] || output="$(git branch | perl -ne '/^\* \(detached from (.*)\)$/ ? print "($1)" : /^\* (.*)/ && print $1')"
  flags="$(
    echo "$status" | awk 'BEGIN {r=""} \
      /^# Changes to be committed:$/        {r=r "+"}\
      /^# Changes not staged for commit:$/  {r=r "!"}\
      /^# Untracked files:$/                {r=r "?"}\
      END {print r}'
  )"
  if [[ "$flags" ]]; then
    output="$output$c1:$c0$flags"
  fi
  echo "$c1[$c0$output$c1]$c9"
}

# hg status.
function prompt_hg() {
  prompt_getcolors
  local summary output bookmark flags
  summary="$(hg summary 2>/dev/null)"
  [[ $? != 0 ]] && return;
  output="$(echo "$summary" | awk '/branch:/ {print $2}')"
  bookmark="$(echo "$summary" | awk '/bookmarks:/ {print $2}')"
  flags="$(
    echo "$summary" | awk 'BEGIN {r="";a=""} \
      /(modified)/     {r= "+"}\
      /(unknown)/      {a= "?"}\
      END {print r a}'
  )"
  output="$output:$bookmark"
  if [[ "$flags" ]]; then
    output="$output$c1:$c0$flags"
  fi
  echo "$c1[$c0$output$c1]$c9"
}

# SVN info.
function prompt_svn() {
  prompt_getcolors
  local info="$(svn info . 2> /dev/null)"
  local last current
  if [[ "$info" ]]; then
    last="$(echo "$info" | awk '/Last Changed Rev:/ {print $4}')"
    current="$(echo "$info" | awk '/Revision:/ {print $2}')"
    echo "$c1[$c0$last$c1:$c0$current$c1]$c9"
  fi
}

# Maintain a per-execution call stack.
prompt_stack=()
trap 'prompt_stack=("${prompt_stack[@]}" "$BASH_COMMAND")' DEBUG

function prompt_command() {
  local exit_code=$?
  # If the first command in the stack is prompt_command, no command was run.
  # Set exit_code to 0 and reset the stack.
  [[ "${prompt_stack[0]}" == "prompt_command" ]] && exit_code=0
  prompt_stack=()

  # Manually load z here, after $? is checked, to keep $? from being clobbered.
  [[ "$(type -t _z)" ]] && _z --add "$(pwd -P 2>/dev/null)" 2>/dev/null

  # While the simple_prompt environment var is set, disable the awesome prompt.
  [[ "$simple_prompt" ]] && PS1='\n$ ' && return

  prompt_getcolors
  # http://twitter.com/cowboy/status/150254030654939137
  PS1="\n"
  # svn: [repo:lastchanged]
  PS1="$PS1$(prompt_svn)"
  # git: [branch:flags]
  PS1="$PS1$(prompt_git)"
  # hg:  [branch:flags]
  PS1="$PS1$(prompt_hg)"
  # misc: [cmd#:hist#]
  # PS1="$PS1$c1[$c0#\#$c1:$c0!\!$c1]$c9"
  # path: [user@host:path]
  PS1="$PS1$c1[$c0\u$c1@$c0\h$c1:$c0\w$c1]$c9"
  PS1="$PS1\n"
  # date: [HH:MM:SS]
  PS1="$PS1$c1[$c0$(date +"%H$c1:$c0%M$c1:$c0%S")$c1]$c9"
  # exit code: 127
  PS1="$PS1$(prompt_exitcode "$exit_code")"
  PS1="$PS1 \$ "
}

PROMPT_COMMAND="prompt_command"

